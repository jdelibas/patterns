{"mappings":"MAWAA,EAAiB,CAXjBC,YAAoB,EAApBC,OAAuBA,EAAvBC,MAA+BA,KAAaC,IAC1C,MAAOC,EAAKC,GAAOH,GACZI,EAAWC,GAAaN,EAIzBO,EAASF,GAHIC,EAAYD,IACbD,EAAMD,IAEYD,EAAQC,GAC5C,OAAII,GAAU,EAAUF,EACjBE,UCRHT,EAAAC,YAEN,MAAMS,EAASC,SAASC,eAAe,UACjCC,EAAMH,EAAOI,WAAW,MAExBC,EAAI,EAAIC,KAAKC,GAAK,EAGxB,IAAIC,EAAO,GAGXC,OAAOC,iBAAiB,SAAUC,GAElC,IAEIC,EAAaC,EAAWC,EAAKC,EAAMC,EADnCC,EAAa,EAUjB,SAASC,EAAQC,GAMfC,sBAAsBF,GAEtBJ,EAAMK,EACNH,EAAUF,EAAMC,EAEZC,EAAUJ,IAGVG,EAAOD,EAAOE,EAAUJ,EAExBK,IAYN,SAAqBI,GACnB,IAAKb,EAAKc,OACR,OAEFC,QAAQC,IAAIH,GAGZI,EAASjB,EAAMa,GAlBXK,CAAYT,GACRA,GA9BE,KA+BJA,EAAa,IAmBrB,SAASN,IACP,MAAMgB,EAASlB,OAAOmB,YAChBC,EAAQpB,OAAOqB,WACrB9B,EAAO6B,MAAQA,EACf7B,EAAO2B,OAASA,EAChBJ,QAAQC,IAAIK,EAAOF,GACnBnB,EAUF,SAAuBqB,EAAOF,GAC5B,MAAMI,EAAO,GACb,IAAK,IAAIC,EA1ED,GA0EQA,EA1ER,GA0EgB1B,KAAK2B,IAAI5B,GAAKsB,EAAQK,GA1EtC,GA0E+C1B,KAAK2B,IAAI5B,GAAI,CAClE,MAAM6B,EAAM,GACZ,IAAK,IAAIC,EA5EH,GA4EUC,EAAI,EAAGD,EA5EjB,IA4E0B,EAAI7B,KAAK+B,IAAIhC,IAAMwB,EAAOM,GA5EpD,IA4E8D,EAAI7B,KAAK+B,IAAIhC,IAAK2B,KAAM,IAAOI,IA5E7F,GA4EuG9B,KAAK2B,IAAI5B,GACpH6B,EAAII,KAAK,CACPC,OAAQ,CApFhBJ,EAoFkBA,EApFlBH,EAoFqBA,GACbQ,OAAQC,EAAaN,EAAGH,GACxBU,KAAMC,MAGVZ,EAAKO,KAAKJ,GAEZ,OAAOH,EAvBAa,CAAcf,EAAOF,GAC5BF,EAASjB,GAGX,MAEMmC,GADQhD,EACM,EADDC,EA7DP,GA6De,IAgE3B,SAA+BD,EAAKC,GAClC,OAAOU,KAAKuC,MAAMvC,KAAKwC,UAAYlD,EAAMD,EAAM,GAAKA,GAjErBoD,CAAsBpD,EAAKC,IAA/C,IAACD,EAAKC,EAGnB,MAAMoD,EAAaC,EAAY,CAAEzD,OAAQ,CAAC,EAJxB,IAIuCC,MAAO,CAAC,EAAG,OAkBpE,SAASgD,EAAaN,EAAGH,GACvB,MAAMQ,EAAS,GAEf,IAAK,IAAIU,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,MAAMC,EAAQ,CACZhB,EAAGA,EA7FC,GA6FO7B,KAAK+B,IAAIhC,EAAI6C,GACxBlB,EAAGA,EA9FC,GA8FO1B,KAAK2B,IAAI5B,EAAI6C,IAE1BV,EAAOF,KAAKa,GAEd,OAAOX,EAGT,SAASf,EAASM,EAAMV,EAAQ,GAC9BlB,EAAIiD,UAAU,EAAG,EAAGpD,EAAO6B,MAAO7B,EAAO2B,QACzC,IAAI,MAAM0B,KAAUtB,EAClB,IAAI,MAAMuB,KAAOD,EACfE,EAAQD,GACRE,EACEF,EAAIf,OAAOJ,EACXmB,EAAIf,OAAOP,EACXgB,EAAWM,EAAIZ,KAAOrB,IAM9B,SAASkC,EAAQD,GACfnD,EAAIsD,YACJtD,EAAIuD,OAAOJ,EAAId,OAAO,GAAGL,EAAGmB,EAAId,OAAO,GAAGR,GAC1C,IAAK,IAAIkB,EAAI,EAAGA,EAAII,EAAId,OAAOlB,OAAQ4B,IACrC/C,EAAIwD,OAAOL,EAAId,OAAOU,GAAGf,EAAGmB,EAAId,OAAOU,GAAGlB,GAE5C7B,EAAIyD,YACJzD,EAAI0D,SAGN,SAASL,EAAWrB,EAAGH,EAAG8B,GACxB3D,EAAIsD,YACJtD,EAAI4D,IAAI5B,EAAGH,EAAG8B,EAAK,EAAG,EAAIxD,KAAKC,IAC/BJ,EAAI0D,SAQNlD,IA3HEC,EAAc,IAPJ,GAQVG,EAAON,OAAOuD,YAAYC,MAC1BpD,EAAYE,EACZG","sources":["src/scale.js","src/main.js"],"sourcesContent":["const scaleLinear = ({ domain, range }) => (value) =>  {\n  const [min, max] = range\n  const [minDomain, maxDomain] = domain\n  const domainDiff = maxDomain - minDomain\n  const rangeDiff = max - min\n  const scale = domainDiff / rangeDiff\n  const newVal = minDomain + scale * (value - min)\n  if (newVal <= 0) return minDomain\n  return newVal\n}\n\nmodule.exports = {\n  scaleLinear,\n}\n","const { scaleLinear } = require('./scale')\n\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d');\n\nconst a = 2 * Math.PI / 6;\nconst r = 50;\n\nlet grid = []\nlet frameGrid = []\n\nwindow.addEventListener('resize', init);\nconst fps = 60;\nlet stop = false;\nlet frameCount = 0;\nlet fpsInterval, startTime, now, then, elapsed;\n\n\nfunction startAnimating(fps) {\n  fpsInterval = 1000 / fps;\n  then = window.performance.now();\n  startTime = then;\n  animate();\n}\nfunction animate(newtime) {\n  // stop\n  if (stop) {\n      return;\n  }\n  // request another frame\n  requestAnimationFrame(animate);\n  // calc elapsed time since last loop\n  now = newtime;\n  elapsed = now - then;\n  // if enough time has elapsed, draw the next frame\n  if (elapsed > fpsInterval) {\n      // Get ready for next frame by setting then=now, but...\n      // Also, adjust for fpsInterval not being multiple of 16.67\n      then = now - (elapsed % fpsInterval);\n      // draw stuff here\n      frameCount++;\n      animateGrid(frameCount)\n      if (frameCount >= fps) {\n        frameCount = 0;\n      }\n  }\n}\n\n\n\n\nconst offset = 1\nfunction animateGrid(frame) {\n  if (!grid.length) {\n    return\n  }\n  console.log(frame)\n\n  // frameGrid = []\n  drawGrid(grid, frame)\n}\n\nfunction init() {\n  const height = window.innerHeight\n  const width = window.innerWidth\n  canvas.width = width;\n  canvas.height = height;\n  console.log(width, height);\n  grid = getGridPoints(width, height);\n  drawGrid(grid)\n}\n\nconst maxRadius = 50\nconst seed = (min, max) => () => randomIntFromInterval(min, max)\nconst seeder = seed(1, fps)\n\nconst radiusStep = scaleLinear({ domain: [1, maxRadius], range: [1, 50 + fps] })\n\nfunction getGridPoints(width, height) {\n  const grid = []\n  for (let y = r; y + r * Math.sin(a) < height; y += r * Math.sin(a)) {\n    const row = []\n    for (let x = r, j = 0; x + r * (1 + Math.cos(a)) < width; x += r * (1 + Math.cos(a)), y += (-1) ** j++ * r * Math.sin(a)) {\n      row.push({\n        center: { x, y },\n        points: getHexPoints(x, y),\n        seed: seeder()\n      })\n    }\n    grid.push(row)\n  }\n  return grid;\n}\n\nfunction getHexPoints(x, y) {\n  const points = [];\n  // ctx.beginPath();\n  for (let i = 0; i < 6; i++) {\n    const point = {\n      x: x + r * Math.cos(a * i),\n      y: y + r * Math.sin(a * i)\n    }\n    points.push(point);\n  }\n  return points\n}\n\nfunction drawGrid(grid, frame = 0) {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  for(const column of grid) {\n    for(const hex of column) {\n      drawHex(hex)\n      drawCircle(\n        hex.center.x,\n        hex.center.y,\n        radiusStep(hex.seed + frame)\n      )\n    }\n  }\n}\n\nfunction drawHex(hex) {\n  ctx.beginPath();\n  ctx.moveTo(hex.points[0].x, hex.points[0].y);\n  for (let i = 1; i < hex.points.length; i++) {\n    ctx.lineTo(hex.points[i].x, hex.points[i].y);\n  }\n  ctx.closePath();\n  ctx.stroke();\n}\n\nfunction drawCircle(x, y, rad) {\n  ctx.beginPath();\n  ctx.arc(x, y, rad, 0, 2 * Math.PI);\n  ctx.stroke();\n}\n\nfunction randomIntFromInterval(min, max) { // min and max included\n  return Math.floor(Math.random() * (max - min + 1) + min)\n}\n\n\ninit();\nstartAnimating(fps)\n"],"names":["$24d48a433bf625d0$exports","scaleLinear","domain","range","value","min","max","minDomain","maxDomain","newVal","$aa459f0fea9822fe$var$canvas","document","getElementById","$aa459f0fea9822fe$var$ctx","getContext","$aa459f0fea9822fe$var$a","Math","PI","$aa459f0fea9822fe$var$grid","window","addEventListener","$aa459f0fea9822fe$var$init","$aa459f0fea9822fe$var$fpsInterval","$aa459f0fea9822fe$var$startTime","$aa459f0fea9822fe$var$now","$aa459f0fea9822fe$var$then","$aa459f0fea9822fe$var$elapsed","$aa459f0fea9822fe$var$frameCount","$aa459f0fea9822fe$var$animate","newtime","requestAnimationFrame","frame","length","console","log","$aa459f0fea9822fe$var$drawGrid","$aa459f0fea9822fe$var$animateGrid","height","innerHeight","width","innerWidth","grid","y","sin","row","x","j","cos","push","center","points","$aa459f0fea9822fe$var$getHexPoints","seed","$aa459f0fea9822fe$var$seeder","$aa459f0fea9822fe$var$getGridPoints","floor","random","$aa459f0fea9822fe$var$randomIntFromInterval","$aa459f0fea9822fe$var$radiusStep","$aa459f0fea9822fe$require$scaleLinear","i","point","clearRect","column","hex","$aa459f0fea9822fe$var$drawHex","$aa459f0fea9822fe$var$drawCircle","beginPath","moveTo","lineTo","closePath","stroke","rad","arc","performance","now"],"version":3,"file":"index.2b6df93b.js.map"}